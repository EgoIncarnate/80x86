// vi: ft=systemverilog
`ifndef MICROCODE_ROM_PATH
`define MICROCODE_ROM_PATH "."
`endif

module Microcode(input logic clk,
                 input logic reset,
                 input logic stall,
                 input logic rm_is_reg,
                 input logic [2:0] modrm_reg,
                 input logic zf,
                 output logic [15:0] microcode_immediate,
                 output logic use_microcode_immediate,
                 output logic segment_override,
                 output logic [7:0] opcode,
                 input logic jump_taken,
                 output logic lock,
                 // Microinstruction fields.
                 <%#exported_fields%>
                 output logic <%type%><%name%>,
                 <%/exported_fields%>
                 // Fifo Read Port.
                 output logic fifo_rd_en,
                 input logic [7:0] fifo_rd_data,
                 input logic fifo_empty);

localparam num_instructions = <%num_instructions%>;
localparam addr_bits = <%addr_bits%>;
localparam reset_address = <%addr_bits%>'h100;

typedef struct packed {
<%#fields%>
    logic <%type%><%name%>;
<%/fields%>
} microcode_instruction;

assign segment_override = current.prefix_type == PrefixType_SEGMENT_OVERRIDE;
assign use_microcode_immediate = |current.immediate;

always_comb begin
    case (current.immediate)
<%#immediates%>
    <%idx%>: microcode_immediate = 16'h<%val%>;
<%/immediates%>
    default: microcode_immediate = 16'h0;
    endcase
end

microcode_instruction mem[num_instructions];
microcode_instruction current;
reg [addr_bits-1:0] addr;
assign current = mem[addr];

<%#exported_fields%>
assign <%name%> = current.<%name%>;
<%/exported_fields%>

assign fifo_rd_en = ~reset & current.fifo_pop & ~opcode_popped & ~fifo_empty;
wire do_stall = stall | fifo_rd_en | (current.fifo_pop & !opcode_popped);

reg opcode_popped;
reg [1:0] rep_prefix_type;
wire has_rep_prefix = (rep_prefix_type == PrefixType_REPE ||
                       rep_prefix_type == PrefixType_REPNE);
reg rep_complete;
reg [7:0] opcode;

int i;
initial begin
    for (i = 0; i < num_instructions; i = i + 1)
        mem[i] = 0;
    $readmemb({{`MICROCODE_ROM_PATH, "/microcode.bin"}}, mem);
end

always_comb begin
    case (rep_prefix_type)
    PrefixType_REPE: rep_complete = ~zf;
    PrefixType_REPNE: rep_complete = zf;
    default: rep_complete = 1'b0;
    endcase
end

always_ff @(posedge clk or posedge reset)
    if (reset || !do_stall)
        opcode_popped <= 1'b0;
    else if (fifo_rd_en)
        opcode_popped <= 1'b1;

always_ff @(posedge clk)
    if (opcode_popped)
        opcode <= fifo_rd_data;

always_ff @(posedge clk or posedge reset)
    if (reset || next_instruction)
        rep_prefix_type <= 2'b0;
    else if (current.prefix_type == PrefixType_REPNE ||
             current.prefix_type == PrefixType_REPE)
        rep_prefix_type <= current.prefix_type;

always_ff @(posedge clk or posedge reset) begin
    if (reset)
        addr <= reset_address;
    else if (!do_stall && current.jump_type == JumpType_JUMP_TAKEN)
        addr <= jump_taken ? current.next : addr + 1'b1;
    else if (!do_stall && current.jump_type == JumpType_ZERO)
        addr <= zf ? current.next : addr + 1'b1;
    else if (!do_stall && current.jump_type == JumpType_HAS_NO_REP_PREFIX)
        addr <= ~has_rep_prefix ? current.next : addr + 1'b1;
    else if (!do_stall && current.jump_type == JumpType_REP_NOT_COMPLETE)
        addr <= !rep_complete ? current.next : addr + 1'b1;
    else if (!do_stall && current.jump_type == JumpType_DISPATCH_REG)
        addr <= current.next + {{addr_bits-3{1'b0}}, modrm_reg};
    else if (!do_stall && current.jump_type == JumpType_RM_REG_MEM)
        addr <= current.next + {{addr_bits-1{1'b0}}, ~rm_is_reg};
    else if (!do_stall && current.jump_type == JumpType_OPCODE)
        addr <= {{addr_bits-8{1'b0}}, fifo_rd_data};
    else if (!do_stall && current.next_instruction)
        addr <= {{addr_bits-9{1'b0}}, 9'h100};
    else if (!do_stall)
        addr <= current.next;
end

always_ff @(posedge clk or posedge reset)
    if (reset || (!do_stall && current.next_instruction))
        lock <= 1'b0;
    else if (current.lock)
        lock <= 1'b1;

`ifdef verilator
export "DPI-C" function get_microcode_address;

function [addr_bits-1:0] get_microcode_address;
    get_microcode_address = addr;
endfunction
`endif

endmodule;
