.at 0x100;
opcode_fetch:
    ext_int_yield, jmp_opcode;

// See 0xcc in int.us for more details, this is the same thing but for a
// divide error.
.at 0x101;
divide_error:
    b_sel IMMEDIATE, immediate 0x0, alu_op SELB, tmp_wr_en, jmp do_int;

// See 0xcc in int.us for more details, this is the same thing but for a
// IRQ.
.at 0x12b;
    // IRQ number to temp
    a_sel MDR, b_sel IMMEDIATE, immediate 0x4, alu_op MUL, tmp_wr_en,
        jmp do_int;

// See 0xcc in int.us for more details, this is the same thing but for a
// NMI.
.at 0x12a;
nmi:
    b_sel IMMEDIATE, immediate 0x8, alu_op SELB, tmp_wr_en, jmp do_int;

// See 0xcc in int.us for more details, this is the same thing but for a
// single step trap.
.at 0x12c;
single_step:
    b_sel IMMEDIATE, immediate 0x4, alu_op SELB, tmp_wr_en, jmp do_int;

#define INVALID_OPCODE(opc) \
.at opc; \
    jmp invalid_opcode

INVALID_OPCODE(0x0f);
INVALID_OPCODE(0x63);
INVALID_OPCODE(0x64);
INVALID_OPCODE(0x65);
INVALID_OPCODE(0x66);
INVALID_OPCODE(0x67);
INVALID_OPCODE(0xf1);

.auto_address;
invalid_opcode:
    b_sel IMMEDIATE, immediate 0x18, alu_op SELB, tmp_wr_en, jmp do_int;

// Multiplexed add/adc/sub/sbb/cmp/xor/or/and
// r/m OP immed8
.at 0x80;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_80;
.auto_address;
dispatch_80:
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADD80_reg; // reg == 0
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem OR80_reg; // reg == 1
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADC80_reg; // reg == 2
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SBB80_reg; // reg == 3
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem AND80_reg; // reg == 4
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SUB80_reg; // reg == 5
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem XOR80_reg; // reg == 6
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compSUB80_reg; // reg == 7

// Multiplexed add/adc/sub/sbb/cmp/xor/or/and
// r/m OP immed16
.at 0x81;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_81;
.auto_address;
dispatch_81:
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADD81_reg; // reg == 0
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem OR81_reg; // reg == 1
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADC81_reg; // reg == 2
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SBB81_reg; // reg == 3
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem AND81_reg; // reg == 4
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SUB81_reg; // reg == 5
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem XOR81_reg; // reg == 6
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compSUB81_reg; // reg == 7

// Multiplexed add/adc/sub/sbb/cmp
// r/m OP immed8
.at 0x82;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_80;

// Multiplexed add/adc/sub/sbb/cmp/xor/or/and
// r/m OP immed16
.at 0x83;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_83;
.auto_address;
dispatch_83:
    width 8, read_immed, segment DS, jmp_rm_reg_mem ADD83_reg; // reg == 0
    width 8, read_immed, segment DS, jmp_rm_reg_mem OR83_reg; // reg == 1
    width 8, read_immed, segment DS, jmp_rm_reg_mem ADC83_reg; // reg == 2
    width 8, read_immed, segment DS, jmp_rm_reg_mem SBB83_reg; // reg == 3
    width 8, read_immed, segment DS, jmp_rm_reg_mem AND83_reg; // reg == 4
    width 8, read_immed, segment DS, jmp_rm_reg_mem SUB83_reg; // reg == 5
    width 8, read_immed, segment DS, jmp_rm_reg_mem XOR83_reg; // reg == 6
    width 8, read_immed, segment DS, jmp_rm_reg_mem compSUB83_reg; // reg == 7

// Multiplexed pop/8f
.at 0x8f;
    modrm_start, mar_write, mar_wr_sel EA, segment SS, jmp_dispatch_reg dispatch_8f;
.auto_address;
dispatch_8f:
    ra_sel SP, jmp_rm_reg_mem pop8f_reg; // reg == 0
    next_instruction; // reg == 1
    next_instruction; // reg == 2
    next_instruction; // reg == 3
    next_instruction; // reg == 4
    next_instruction; // reg == 5
    next_instruction; // reg == 6
    next_instruction; // reg == 7

// Multiplexed shift single 8-bit
.at 0xd0;
    width 8, modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_d0;
.auto_address;
dispatch_d0:
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ROLd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RORd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCLd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCRd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHLd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHRd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHLd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SARd0_reg;

// Multiplexed shift single 8-bit by immediate
.at 0xc0;
    width 8, modrm_start, mar_write, mar_wr_sel EA,
	jmp_dispatch_reg dispatch_c0;
.auto_address;
dispatch_c0:
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE,
	ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ROLc0_reg;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE,
	ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RORc0_reg;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE,
	ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCLc0_reg;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE,
	ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCRc0_reg;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE,
	ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHLc0_reg;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE,
	ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHRc0_reg;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE,
	ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHLc0_reg;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE,
	ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SARc0_reg;

// Multiplexed shift single 16-bit by immediate
.at 0xc1;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_c1;
.auto_address;
dispatch_c1:
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE, jmp ROLc1;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE, jmp RORc1;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE, jmp RCLc1;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE, jmp RCRc1;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE, jmp SHLc1;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE, jmp SHRc1;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE, jmp SHLc1;
    width 8, read_immed, tmp_wr_en, alu_op SELB, b_sel IMMEDIATE, jmp SARc1;

// Multiplexed shift single 16-bit
.at 0xd1;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_d1;
.auto_address;
dispatch_d1:
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ROLd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RORd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCLd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCRd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHLd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHRd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHLd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SARd1_reg;

// Multiplexed shift multiple 8-bit
.at 0xd2;
    width 8, modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_d2;
.auto_address;
dispatch_d2:
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp ROLd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp RORd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp RCLd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp RCRd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp SHLd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp SHRd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp SHLd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp SARd2;

// Multiplexed shift multiple 16-bit
.at 0xd3;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_d3;
.auto_address;
dispatch_d3:
    ra_modrm_rm_reg, rb_cl, segment DS, jmp ROLd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp RORd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp RCLd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp RCRd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp SHLd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp SHRd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp SHLd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp SARd3;

// Multiplexed neg/mul/not/test/div 8 bit
.at 0xf6;
    width 8, modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_f6;
.auto_address;
dispatch_f6:
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compANDf6_reg; // reg == 0
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compANDf6_reg; // reg == 1
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem notf6_reg; // reg == 3
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem negf6_reg; // reg == 3
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem mulf6_reg; // reg == 4
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem imulf6_reg; // reg == 5
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem divf6_reg; // reg == 6
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem idivf6_reg; // reg == 7

// Multiplexed neg/mul/not/test/div 16 bit
.at 0xf7;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_f7;
.auto_address;
dispatch_f7:
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compANDf7_reg; // reg == 0
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compANDf7_reg; // reg == 1
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem notf7_reg; // reg == 2
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem negf7_reg; // reg == 3
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem mulf7_reg; // reg == 4
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem imulf7_reg; // reg == 5
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem divf7_reg; // reg == 6
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem idivf7_reg; // reg == 7

// Multiplexed push/inc/jmp/call/ff
.at 0xff;
    modrm_start, mar_write, mar_wr_sel EA, segment DS, jmp_dispatch_reg dispatch_ff;
.auto_address;
dispatch_ff:
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem inc_ff_reg; // reg == 0
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem dec_ff_reg; // reg == 1
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem callff_indirect_intra_reg; // reg == 2
    segment_force, segment CS, jmp_rm_reg_mem callff_indirect_inter_reg; // reg == 3
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem jmpff_indirect_intra_reg; // reg == 4
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem jmpff_indirect_inter_reg; // reg == 5
    ra_sel SP, segment DS, jmp_rm_reg_mem pushff_reg; // reg == 6
    jmp invalid_opcode;

.at 0x129;
    jmp reset;

.auto_address;
reset:
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel AX, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel CX, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel DX, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel BX, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel SP, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel BP, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel SI, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel DI, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, segment_force, segment ES,
        segment_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0xffff, segment_force, segment CS,
        segment_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, segment_force, segment SS,
        segment_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, segment_force, segment DS,
        segment_wr_en;
    next_instruction, jmp opcode_fetch;

// Unimplemented opcodes
#define UNIMPLEMENTED(opcode) \
    .at opcode; \
    next_instruction

UNIMPLEMENTED(0x6c);
UNIMPLEMENTED(0x6d);
UNIMPLEMENTED(0x6e);
UNIMPLEMENTED(0x6f);
UNIMPLEMENTED(0xc8);
UNIMPLEMENTED(0xc9);

.auto_address;
write_16_complete:
    segment DS, mem_write, next_instruction;

write_8_complete:
    segment DS, mem_write, width 8, next_instruction;
