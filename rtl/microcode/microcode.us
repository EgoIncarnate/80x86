.at 0x100;
opcode_fetch:
    ext_int_yield, fifo_pop, jmp_opcode;

// See 0xcc in int.us for more details, this is the same thing but for a
// divide error.
.at 0x101;
divide_error:
    alu_op GETFLAGS, mdr_write, ra_sel SP, jmp do_divide_error;
.auto_address;
do_divide_error:
    a_sel RA, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q, segment CS;
    b_sel SR, alu_op SELB, mdr_write, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q;
    a_sel IP, alu_op SELA, mdr_write, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, alu_op SELA, rd_sel_source MICROCODE_RD_SEL,
        rd_sel SP, reg_wr_en;
    b_sel IMMEDIATE, immediate 0x0, alu_op SETFLAGSB, update_flags IF TF;
    b_sel IMMEDIATE, immediate 0x0, alu_op SELB, segment_force,
        sr_wr_sel CS, segment_wr_en;
    b_sel IMMEDIATE, immediate 0x0, alu_op SELB, mar_wr_sel Q,
        mar_write, segment CS, segment_force;
    segment_force, segment CS, mem_read;
    a_sel MDR, alu_op SELA, load_ip;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op ADD, mar_write,
        mar_wr_sel Q, segment CS, segment_force;
    segment_force, segment CS, mem_read;
    a_sel MDR, alu_op SELA, segment_force, sr_wr_sel CS,
        segment_wr_en, next_instruction;

// See 0xcc in int.us for more details, this is the same thing but for a
// IRQ.
.at 0x12b;
    // IRQ number to temp
    a_sel MDR, tmp_wr_en, jmp do_irq;
.auto_address;
do_irq:
    alu_op GETFLAGS, mdr_write, ra_sel SP;
    a_sel RA, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q, segment CS;
    b_sel SR, alu_op SELB, mdr_write, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q;
    a_sel IP, alu_op SELA, mdr_write, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, alu_op SELA, rd_sel_source MICROCODE_RD_SEL,
        rd_sel SP, reg_wr_en;
    b_sel IMMEDIATE, immediate 0x0, alu_op SETFLAGSB, update_flags IF TF;
    b_sel IMMEDIATE, immediate 0x0, alu_op SELB, segment_force,
        sr_wr_sel CS, segment_wr_en;
    b_sel TEMP, alu_op SELB, mar_wr_sel Q, mar_write;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x4, alu_op MUL, mar_wr_sel Q,
        mar_write, segment CS, segment_force;
    segment_force, segment CS, mem_read;
    a_sel MDR, alu_op SELA, load_ip;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op ADD, mar_write,
        mar_wr_sel Q, segment CS, segment_force;
    segment_force, segment CS, mem_read;
    a_sel MDR, alu_op SELA, segment_force, sr_wr_sel CS,
        segment_wr_en, next_instruction;

// See 0xcc in int.us for more details, this is the same thing but for a
// NMI.
.at 0x12a;
nmi:
    alu_op GETFLAGS, mdr_write, ra_sel SP, jmp do_nmi;
.auto_address;
do_nmi:
    a_sel RA, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q, segment CS;
    b_sel SR, alu_op SELB, mdr_write, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q;
    a_sel IP, alu_op SELA, mdr_write, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, alu_op SELA, rd_sel_source MICROCODE_RD_SEL,
        rd_sel SP, reg_wr_en;
    b_sel IMMEDIATE, immediate 0x0, alu_op SETFLAGSB, update_flags IF TF;
    b_sel IMMEDIATE, immediate 0x0, alu_op SELB, segment_force,
        sr_wr_sel CS, segment_wr_en;
    b_sel IMMEDIATE, immediate 0x8, alu_op SELB, mar_wr_sel Q,
        mar_write, segment CS, segment_force;
    segment_force, segment CS, mem_read;
    a_sel MDR, alu_op SELA, load_ip;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op ADD, mar_write,
        mar_wr_sel Q, segment CS, segment_force;
    segment_force, segment CS, mem_read;
    a_sel MDR, alu_op SELA, segment_force, sr_wr_sel CS,
        segment_wr_en, next_instruction;

// See 0xcc in int.us for more details, this is the same thing but for a
// single step trap.
.at 0x12c;
single_step:
    alu_op GETFLAGS, mdr_write, ra_sel SP, jmp do_single_step;
.auto_address;
do_single_step:
    a_sel RA, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q, segment CS;
    b_sel SR, alu_op SELB, mdr_write, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op SUB,
        mar_write, mar_wr_sel Q;
    a_sel IP, alu_op SELA, mdr_write, segment SS, segment_force;
    segment SS, segment_force, mem_write;
    a_sel MAR, alu_op SELA, rd_sel_source MICROCODE_RD_SEL,
        rd_sel SP, reg_wr_en;
    b_sel IMMEDIATE, immediate 0x0, alu_op SETFLAGSB, update_flags IF TF;
    b_sel IMMEDIATE, immediate 0x0, alu_op SELB, segment_force,
        sr_wr_sel CS, segment_wr_en;
    b_sel IMMEDIATE, immediate 0x4, alu_op SELB, mar_wr_sel Q,
        mar_write, segment CS, segment_force;
    segment_force, segment CS, mem_read;
    a_sel MDR, alu_op SELA, load_ip;
    a_sel MAR, b_sel IMMEDIATE, immediate 0x2, alu_op ADD, mar_write,
        mar_wr_sel Q, segment CS, segment_force;
    segment_force, segment CS, mem_read;
    a_sel MDR, alu_op SELA, segment_force, sr_wr_sel CS,
        segment_wr_en, ext_int_inhibit, next_instruction;

// Multiplexed add/adc/sub/sbb/cmp/xor/or/and
// r/m OP immed8
.at 0x80;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_80;
.auto_address;
dispatch_80:
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADD80_reg; // reg == 0
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem OR80_reg; // reg == 1
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADC80_reg; // reg == 2
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SBB80_reg; // reg == 3
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem AND80_reg; // reg == 4
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SUB80_reg; // reg == 5
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem XOR80_reg; // reg == 6
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compSUB80_reg; // reg == 7

// Multiplexed add/adc/sub/sbb/cmp/xor/or/and
// r/m OP immed16
.at 0x81;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_81;
.auto_address;
dispatch_81:
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADD81_reg; // reg == 0
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem OR81_reg; // reg == 1
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADC81_reg; // reg == 2
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SBB81_reg; // reg == 3
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem AND81_reg; // reg == 4
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SUB81_reg; // reg == 5
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem XOR81_reg; // reg == 6
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compSUB81_reg; // reg == 7

// Multiplexed add/adc/sub/sbb/cmp
// r/m OP immed8
.at 0x82;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_82;
.auto_address;
dispatch_82:
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADD82_reg; // reg == 0
    next_instruction; // reg == 1
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ADC82_reg; // reg == 2
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SBB82_reg; // reg == 3
    next_instruction; // reg == 4
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SUB82_reg; // reg == 5
    next_instruction; // reg == 6
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compSUB82_reg; // reg == 7

// Multiplexed add/adc/sub/sbb/cmp/xor/or/and
// r/m OP immed16
.at 0x83;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_83;
.auto_address;
dispatch_83:
    width 8, read_immed, segment DS, jmp_rm_reg_mem ADD83_reg; // reg == 0
    width 8, read_immed, segment DS, jmp_rm_reg_mem OR83_reg; // reg == 1
    width 8, read_immed, segment DS, jmp_rm_reg_mem ADC83_reg; // reg == 2
    width 8, read_immed, segment DS, jmp_rm_reg_mem SBB83_reg; // reg == 3
    width 8, read_immed, segment DS, jmp_rm_reg_mem AND83_reg; // reg == 4
    width 8, read_immed, segment DS, jmp_rm_reg_mem SUB83_reg; // reg == 5
    next_instruction; // reg == 6
    width 8, read_immed, segment DS, jmp_rm_reg_mem compSUB83_reg; // reg == 7

// Multiplexed pop/8f
.at 0x8f;
    modrm_start, mar_write, mar_wr_sel EA, segment SS, jmp_dispatch_reg dispatch_8f;
.auto_address;
dispatch_8f:
    ra_sel SP, jmp_rm_reg_mem pop8f_reg; // reg == 0
    next_instruction; // reg == 1
    next_instruction; // reg == 2
    next_instruction; // reg == 3
    next_instruction; // reg == 4
    next_instruction; // reg == 5
    next_instruction; // reg == 6
    next_instruction; // reg == 7

// Multiplexed shift single 8-bit
.at 0xd0;
    width 8, modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_d0;
.auto_address;
dispatch_d0:
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ROLd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RORd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCLd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCRd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHLd0_reg;
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHRd0_reg;
    next_instruction; // reg == 6
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SARd0_reg;

// Multiplexed shift single 16-bit
.at 0xd1;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_d1;
.auto_address;
dispatch_d1:
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem ROLd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RORd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCLd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem RCRd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHLd1_reg;
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SHRd1_reg;
    next_instruction; // reg == 6
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem SARd1_reg;

// Multiplexed shift multiple 8-bit
.at 0xd2;
    width 8, modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_d2;
.auto_address;
dispatch_d2:
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp ROLd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp RORd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp RCLd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp RCRd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp SHLd2;
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp SHRd2;
    next_instruction; // reg == 6
    width 8, ra_modrm_rm_reg, rb_cl, segment DS, jmp SARd2;

// Multiplexed shift multiple 16-bit
.at 0xd3;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_d3;
.auto_address;
dispatch_d3:
    ra_modrm_rm_reg, rb_cl, segment DS, jmp ROLd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp RORd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp RCLd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp RCRd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp SHLd3;
    ra_modrm_rm_reg, rb_cl, segment DS, jmp SHRd3;
    next_instruction; // reg == 6
    ra_modrm_rm_reg, rb_cl, segment DS, jmp SARd3;

// Multiplexed neg/mul/not/test/div 8 bit
.at 0xf6;
    width 8, modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_f6;
.auto_address;
dispatch_f6:
    width 8, read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compANDf6_reg; // reg == 0
    next_instruction; // reg == 1
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem notf6_reg; // reg == 3
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem negf6_reg; // reg == 3
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem mulf6_reg; // reg == 4
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem imulf6_reg; // reg == 5
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem divf6_reg; // reg == 6
    width 8, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem idivf6_reg; // reg == 7

// Multiplexed neg/mul/not/test/div 16 bit
.at 0xf7;
    modrm_start, mar_write, mar_wr_sel EA, jmp_dispatch_reg dispatch_f7;
.auto_address;
dispatch_f7:
    read_immed, ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem compANDf7_reg; // reg == 0
    next_instruction; // reg == 1
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem notf7_reg; // reg == 2
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem negf7_reg; // reg == 3
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem mulf7_reg; // reg == 4
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem imulf7_reg; // reg == 5
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem divf7_reg; // reg == 6
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem idivf7_reg; // reg == 7

// Multiplexed push/inc/jmp/call/ff
.at 0xff;
    modrm_start, mar_write, mar_wr_sel EA, segment DS, jmp_dispatch_reg dispatch_ff;
.auto_address;
dispatch_ff:
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem inc_ff_reg; // reg == 0
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem dec_ff_reg; // reg == 1
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem callff_indirect_intra_reg; // reg == 2
    segment_force, segment CS, jmp_rm_reg_mem callff_indirect_inter_reg; // reg == 3
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem jmpff_indirect_intra_reg; // reg == 4
    ra_modrm_rm_reg, segment DS, jmp_rm_reg_mem jmpff_indirect_inter_reg; // reg == 5
    ra_sel SP, segment DS, jmp_rm_reg_mem pushff_reg; // reg == 6
    next_instruction; // reg == 7

.at 0x129;
    jmp reset;

.auto_address;
reset:
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel AX, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel CX, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel DX, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel BX, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel SP, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel BP, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel SI, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, rd_sel_source MICROCODE_RD_SEL,
        rd_sel DI, reg_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, segment_force, sr_wr_sel ES,
        segment_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0xffff, segment_force, sr_wr_sel CS,
        segment_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, segment_force, sr_wr_sel SS,
        segment_wr_en;
    b_sel IMMEDIATE, alu_op SELB, immediate 0x0, segment_force, sr_wr_sel DS,
        segment_wr_en;
    next_instruction, jmp opcode_fetch;

// Unimplemented opcodes
.at 0xc0;
    next_instruction;
.at 0xc1;
    next_instruction;
.at 0xc8;
    next_instruction;
.at 0xc9;
    next_instruction;
.at 0xd6;
    next_instruction;
.at 0xf1;
    next_instruction;
