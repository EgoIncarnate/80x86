= s80x86 Core Development Guide
Jamie Iles <jamie@jamieiles.com>

:source-highlighter: coderay

== Building

=== System Requirements

- Docker, tested with version 1.12.1.

=== Quick Start Build

The `scripts/build` script provides everything that is needed to quickly build
and test the project.  On the first run, the script will build the required
Docker images from `docker/build/Dockerfile`, configure and build the project
and run all of the built-in tests.

[source,bash]
----
./scripts/build
----

=== Build Environments

The s80x86 project uses Docker to provide convenient build environments.  This
means that it is possible to build and test the design on any Linux system
with Docker, regardless of distribution.  The Docker images used internally
are all based on Ubuntu 16.04 LTS.

There are two primary build environments:

  - s80x86-build
  - s80x86-dev

Each build environment has a script in `docker` to enter the container and
build it if not already built.  A 'ccache' cache is created in
`_build/.ccache` that persists across container runs to increase build
performance.

's80x86-build' is a minimal Ubuntu 16.04 LTS container with the dependencies for
building the project and running the tests.  This environment runs everything
as the current user's uid/gid to preserve file permissions outside of the
container and bind-mounts the project directory into `/build`.  The
's80x86-build' container 

's80x86-dev' is intended for developing the project itself and includes extra
packages and convenience scripts to make developing easier.  Unlike the
's80x86-build' container, this container bind mounts `/home` from the host
into the container for convenience and includes packages like GTKWave for
viewing waveforms.  It is recommended to use the Docker build environments for
all builds and developments as those are used for the baseline development and
verification.

=== CI Build Scripts

Several build scripts are included suitable for use in a continuous
integration environment.

*scripts/ci/unittest* builds the project from scratch and then runs all of the
unit tests, producing JUnit XML suitable for importing into the CI test runner
history.

*scripts/ci/gcov-coverage* performs the same steps as `scripts/ci/coverage`
but produces Cobertura compatible coverage information that can be read into
Jenkins or other CI systems supporting this format.

=== Build Configurations

The CMake based build system supports the following build configurations and
can be selected by passing `-DCMAKE_BUILD_TYPE=`'CONFIGURATION' to `cmake`.

*Release* is optimized for performance, no debug information.

*Debug* enables debug information in all C/{cpp} executables, and tracing of
Verilog models which will write VCD files for each test run.

*Coverage* builds everything for coverage including {cpp} and Verilog.

== RTL Tests

The RTL tests are written in {cpp}, using Verilator to create {cpp} models of the
Verilog.  For example, given a synchronous Fifo, the Verilator model can be
created using the Verilator CMake package:

[source,cmake]
----
include(Verilator)
add_library(verilator STATIC ${VERILATOR_LIB_SOURCES})
verilate(Fifo ${CMAKE_CURRENT_SOURCE_DIR}/Fifo.v)
----

This will generate a `verilator` library containing the common Verilator
support functions, run Verilator on `Fifo.v` and generate a `VFifo` library
and `VFifo.h` header for inclusion in the test code.  A templated wrapper
'VerilogTestbench' in `VerilogTestbench.h` provides convenient methods for
resetting and clocking the device under test along with running deferred and
clock edge events, tracing and coverage.

The device under test can then be encapsulated inside a class and used for
writing tests with Google Test.  For example, wrapping the Verilog model:

[source,c++]
----
#include <VFifo.h>

#include "VerilogTestbench.h"

class FifoTestbench : public VerilogTestbench<VFifo> {
public:
    FifoTestbench(VFifo *dut);
    void push(uint32_t val);
    uint32_t pop();
};

FifoTestbench::FifoTestbench(VFifo *dut)
    : VerilogTestbench<VFifo>(dut)
{
    dut->wr_en = 0;
    dut->wr_data = 0LU;
    dut->rd_en = 0;
}

void FifoTestbench::push(uint32_t val)
{
    dut->wr_data = val;
    dut->wr_en = 1;
    cycle();
    dut->wr_en = 0;
}

uint32_t FifoTestbench::pop()
{
    dut->rd_en = 1;
    cycle();
    dut->rd_en = 0;

    return dut->rd_data;
}
----

Then a test can be written to exercise it:

[source,c++]
----
TEST(Fifo, ResetClears)
{
    FifoTestbench tb;

    for (uint32_t m = 0; m < 4; ++m)
        tb.push(m);

    ASSERT_FALSE(tb.dut->empty);
    tb.reset();
    ASSERT_TRUE(tb.dut->empty);
}
----

More complex tests that have deferred events such as reading from memory can
be written by adding events on positive+negative clock edges and running after
a number of cycles.  `tests/rtl/TestPrefetch.cpp` uses a number of these
concepts.  With the right abstractions it can be possible to type-parameterize
these test cases to run against pure software simulations and Verilog models.

== Microcode

The microcode is stored in `rtl/microcode` where microcode files have the
`.us` suffix.  The microassembler first passes these files through the C
preprocessor to allow inclusion of other files and creating macros.

=== Directives

Directives are used to provide information to the microassembler about
microcode layout without actually generating microinstructions.

==== .opcode NUM

The `.opcode NUM` directive tells the microassembler to insert the next
microinstruction at address `NUM` in the microprogram.  This is used for the
first 256 opcodes so that efficient dispatch can be performed by jumping to
the address corresponding to the value of the opcode.

==== .auto_address

Returns the address assignment to automatically assigned addresses after using
the `.opcode` directive.

=== Microinstruction Fields

==== jmp_rm_reg_mem

`jmp_rm_reg_mem LABEL` tells the microassembler to generate a jump that will
jump to the label if the Mod R/M decoder indicates a register operand in the
R/M field and the label + 1 if the R/M field encodes a memory operand.  For
example:

[source,asm]
----
    jmp_rm_reg_mem foo_reg;
foo_reg:
    next_instruction;
foo_mem:
    next_instruction;
----

will jump to `foo_reg` if the R/M operand is a register operand and `foo_mem`
if the R/M operand is a memory operand.  The two microinstructions must be
adjacent with the register based instruction appearing first.
