= s80x86 Core Development Guide
Jamie Iles <jamie@jamieiles.com>

:source-highlighter: coderay

== Building

=== System Requirements

- Docker, tested with version 1.12.1.

=== Quick Start Build

The `scripts/build` script provides everything that is needed to quickly build
and test the project.  On the first run, the script will build the required
Docker images from `docker/build/Dockerfile`, configure and build the project
and run all of the built-in tests.

[source,bash]
----
./scripts/build
----

=== Build Environments

The s80x86 project uses Docker to provide convenient build environments.  This
means that it is possible to build and test the design on any Linux system
with Docker, regardless of distribution.  The Docker images used internally
are all based on Ubuntu 16.04 LTS.

There are two primary build environments:

  - s80x86-build
  - s80x86-dev

Each build environment has a script in `docker` to enter the container and
build it if not already built.  A 'ccache' cache is created in
`_build/.ccache` that persists across container runs to increase build
performance.

's80x86-build' is a minimal Ubuntu 16.04 LTS container with the dependencies for
building the project and running the tests.  This environment runs everything
as the current user's uid/gid to preserve file permissions outside of the
container and bind-mounts the project directory into `/build`.  The
's80x86-build' container 

's80x86-dev' is intended for developing the project itself and includes extra
packages and convenience scripts to make developing easier.  Unlike the
's80x86-build' container, this container bind mounts `/home` from the host
into the container for convenience and includes packages like GTKWave for
viewing waveforms.  It is recommended to use the Docker build environments for
all builds and developments as those are used for the baseline development and
verification.

=== CI Build Scripts

Several build scripts are included suitable for use in a continuous
integration environment.

*scripts/ci/unittest* builds the project from scratch and then runs all of the
unit tests, producing JUnit XML suitable for importing into the CI test runner
history.

*scripts/ci/gcov-coverage* performs the same steps as `scripts/ci/coverage`
but produces Cobertura compatible coverage information that can be read into
Jenkins or other CI systems supporting this format.

=== Build Configurations

The CMake based build system supports the following build configurations and
can be selected by passing `-DCMAKE_BUILD_TYPE=`'CONFIGURATION' to `cmake`.

*Release* is optimized for performance, no debug information.

*Debug* enables debug information in all C/{cpp} executables, and tracing of
Verilog models which will write VCD files for each test run.

*Coverage* builds everything for coverage including {cpp} and Verilog.

== RTL Tests

The RTL tests are written in {cpp}, using Verilator to create {cpp} models of the
Verilog.  For example, given a synchronous Fifo, the Verilator model can be
created using the Verilator CMake package:

[source,cmake]
----
include(Verilator)
add_library(verilator STATIC ${VERILATOR_LIB_SOURCES})
verilate(Fifo ${CMAKE_CURRENT_SOURCE_DIR}/Fifo.v)
----

This will generate a `verilator` library containing the common Verilator
support functions, run Verilator on `Fifo.v` and generate a `VFifo` library
and `VFifo.h` header for inclusion in the test code.  A templated wrapper
'VerilogTestbench' in `VerilogTestbench.h` provides convenient methods for
resetting and clocking the device under test along with running deferred and
clock edge events, tracing and coverage.

The device under test can then be encapsulated inside a class and used for
writing tests with Google Test.  For example, wrapping the Verilog model:

[source,c++]
----
#include <VFifo.h>

#include "VerilogTestbench.h"

class FifoTestbench : public VerilogTestbench<VFifo> {
public:
    FifoTestbench(VFifo *dut);
    void push(uint32_t val);
    uint32_t pop();
};

FifoTestbench::FifoTestbench(VFifo *dut)
    : VerilogTestbench<VFifo>(dut)
{
    dut->wr_en = 0;
    dut->wr_data = 0LU;
    dut->rd_en = 0;
}

void FifoTestbench::push(uint32_t val)
{
    dut->wr_data = val;
    dut->wr_en = 1;
    cycle();
    dut->wr_en = 0;
}

uint32_t FifoTestbench::pop()
{
    dut->rd_en = 1;
    cycle();
    dut->rd_en = 0;

    return dut->rd_data;
}
----

Then a test can be written to exercise it:

[source,c++]
----
TEST(Fifo, ResetClears)
{
    FifoTestbench tb;

    for (uint32_t m = 0; m < 4; ++m)
        tb.push(m);

    ASSERT_FALSE(tb.dut->empty);
    tb.reset();
    ASSERT_TRUE(tb.dut->empty);
}
----

More complex tests that have deferred events such as reading from memory can
be written by adding events on positive+negative clock edges and running after
a number of cycles.  `tests/rtl/TestPrefetch.cpp` uses a number of these
concepts.  With the right abstractions it can be possible to type-parameterize
these test cases to run against pure software simulations and Verilog models.

== Microcode

The microcode is stored in `rtl/microcode` where microcode files have the
`.us` suffix.  The microassembler first passes these files through the C
preprocessor to allow inclusion of other files and creating macros.

=== Directives

Directives are used to provide information to the microassembler about
microcode layout without actually generating microinstructions.

==== .opcode NUM

The `.opcode NUM` directive tells the microassembler to insert the next
microinstruction at address `NUM` in the microprogram.  This is used for the
first 256 opcodes so that efficient dispatch can be performed by jumping to
the address corresponding to the value of the opcode.

==== .auto_address

Returns the address assignment to automatically assigned addresses after using
the `.opcode` directive.

=== Microinstruction Fields

==== jmp_rm_reg_mem

`jmp_rm_reg_mem LABEL` tells the microassembler to generate a jump that will
jump to the label if the Mod R/M decoder indicates a register operand in the
R/M field and the label + 1 if the R/M field encodes a memory operand.  For
example:

[source,asm]
----
    jmp_rm_reg_mem foo_reg;
foo_reg:
    next_instruction;
foo_mem:
    next_instruction;
----

will jump to `foo_reg` if the R/M operand is a register operand and `foo_mem`
if the R/M operand is a memory operand.  The two microinstructions must be
adjacent with the register based instruction appearing first.

== Debug

The microsequencer provides a very simple way to implement on-chip debug.  The
core has a number of signals to interface between a debug controller
(typically JTAG) and the microsequencer.  These signals are all in the core
clock domain and will require synchronization with a debug controller in a
different clock domain.

The debug mechanism works by putting the core into a halt mode where it will
perform a tight loop in the microsequencer at which point other debug
operations can be issued.  Operations are issued by running a microprogram at
a known address allowing more debug procedures to be added easily.  To perform
a debug operation, the debug controller first halts the core by raising
`debug_seize` and waits for the core to enter the halted state with
`debug_stopped` asserted which will be at the end of the current microprogram.
Once stopped, the controller can write data to the temporary register if
required with `debug_wr_val` and `debug_wr_en` and then run the debug procedure
by writing the procedure address to `debug_addr` and asserting `debug_run` for
a single clock cycle.

=== Debug Signals

.Debug Interface Signals
[cols="2,1,1,3",options="header"]
|===
| Name | Width | Direction | Description

| debug_stopped | 1 | output | Asserted when the core is in a debug halt and
  is ready for debug operations.  The debug controller must not issue any
  operations when `debug_stopped` is not asserted.
| debug_seize | 1 | input | Asserted by the controller to request that the core
  enters debug mode.  This may be deasserted once `debug_stopped` has been
  asserted and then the run procedure executed to continue normal operation.
| debug_addr | 8 | input | The address of the debug procedure to execute, must
  be written at the same time as `debug_run`.  The core will run the procedure
  at 100h + `debug_addr`.
| debug_run | 1 | input | Asserted by the debug controller to begin the debug
  procedure specified in `debug_addr`.
| debug_wr_val | 16 | input | Asserted by the debug controller to write the
  value in `debug_wr_val` into the temporary register.
| debug_wr_en | 1 | input | Asserted by the debug controller to write
  `debug_wr_val` into the temporary register.
|===

=== Control and Reserved Debug Procedures

  - *0x00*: resume execution.  If `debug_seize` is held high then this will
  single-step one instruction, otherwise run indefinitely until seized.
  - *0x01 - 0x02: reserved for internal use, execution will yield undefined
  behaviour.*

=== Data Transfer Debug Procedures

These debug procedures are used to transfer data between the debug controller
and the core.

.Data Transfer Debug Procedures
[cols=3*,options="header"]
|===
| Program Number
| Source
| Destination
| 0x03 | `AX` | `debug_val`
| 0x04 | `CX` | `debug_val`
| 0x05 | `DX` | `debug_val`
| 0x06 | `BX` | `debug_val`
| 0x07 | `SP` | `debug_val`
| 0x08 | `BP` | `debug_val`
| 0x09 | `SI` | `debug_val`
| 0x0a | `DI` | `debug_val`
| 0x0b | `ES` | `debug_val`
| 0x0c | `CS` | `debug_val`
| 0x0d | `SS` | `debug_val`
| 0x0e | `DS` | `debug_val`
| 0x0f | `IP` | `debug_val`
| 0x10 | `FLAGS` | `debug_val`
| 0x11 | `debug_val` | `IP`
| 0x12 | `debug_val` | `FLAGS`
| 0x13 | `debug_val` | `AX`
| 0x14 | `debug_val` | `CX`
| 0x15 | `debug_val` | `DX`
| 0x16 | `debug_val` | `BX`
| 0x17 | `debug_val` | `SP`
| 0x18 | `debug_val` | `BP`
| 0x19 | `debug_val` | `SI`
| 0x1a | `debug_val` | `DI`
| 0x1b | `debug_val` | `ES`
| 0x1c | `debug_val` | `CS`
| 0x1d | `debug_val` | `SS`
| 0x1e | `debug_val` | `DS`
| 0x1f | `debug_val` | `IP`
|===
